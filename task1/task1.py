import numpy as np
import timeit

def myVersion(X):
    #simple version
    iRow=0
    iColumn=0
    result=1
    while iRow <X.shape[0] and iColumn<X.shape[1]:
        if X[iRow,iColumn]!=0:
            result*=X[iRow,iColumn]
        iRow+=1
        iColumn+=1
    return result

#print("My")
#%timeit myVersion(np.array([[1, 0, 1], [2, 0, 2], [3, 0, 3], [4, 4, 4]]))
#%timeit myVersion(np.array([[11, 70, 13,12,34,89,34], [0, 0, 2,47,677,90,34], [3, 0, 3,56,23,78,32], [4, 4, 4,87,43,21,45]]))
#%timeit myVersion(np.array([[436,467,876,43,2,4,667,45,78,32], [56,90,45,43,2,44,23,45,78,32], [23,467,57,989,2,4,9,45,90,32], [36,9,876,43,2,4,34,45,6,23],[65,23,876,43,2,4,78,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32]]))

#8.27
#10.2
#RuntimeWarning

def numpyVersion(X):
    #numpy version
    return np.multiply.reduce(X.diagonal()[X.diagonal()>0])

#print("numpy")
#%timeit numpyVersion(np.array([[1, 0, 1], [2, 0, 2], [3, 0, 3], [4, 4, 4]]))
#%timeit numpyVersion(np.array([[11, 70, 13,12,34,89,34], [0, 0, 2,47,677,90,34], [3, 0, 3,56,23,78,32], [4, 4, 4,87,43,21,45]]))
#%timeit numpyVersion(np.array([[436,467,876,43,2,4,667,45,78,32], [56,90,45,43,2,44,23,45,78,32], [23,467,57,989,2,4,9,45,90,32], [36,9,876,43,2,4,34,45,6,23],[65,23,876,43,2,4,78,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32],[436,467,89,43,2,4,667,45,78,32]]))

#11.5
#12.6
#19.7

#Вывод: на большых массивах numpy работает быстрее, возможно это связано с накладными расходами библиотеки при использовании усскорения сторонними решениями